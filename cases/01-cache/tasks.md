# 01 任务：缓存友好的构建（对比 bad vs good）

## 背景
业务上线后，你不希望用户每次发布都重新下载所有资源。你需要用文件名 hash 实现长期缓存，并区分开发/生产构建策略。

## 当前状态
- 反例与正例需要“并排对比”，否则很难直观看到缓存策略的收益。

## 任务清单
### 1. 安装依赖
依赖安装命令请看 `learning.md`（本文件不提供答案命令）。

### 2. 跑通反例（bad）
运行反例构建，确认产物输出为：
- `dist/bad/bundle.js`（固定文件名）

### 3. 跑通正例（good）
运行正例构建，确认产物输出为：
- `dist/good/bundle.[contenthash].js`（带 hash）

### 4. 验证“多版本共存”
做一次小改动（比如改 `src/index.js` 的文案），然后再次运行第1步和第2步中。
验收：
- `dist/bad/` 下体现不出变化，用户要访问最新的内容只能重新下载全部内容
- `dist/good/` 下至少出现 **两个不同 hash 的 bundle 文件**，用户只需要下载变化的部分即可

### 5. 解释原因
思考（检测一下自己是否真的懂了）：
- 为什么 `bundle.js` 不利于长期缓存
- 为什么 `bundle.[contenthash].js` 能让“旧版本资源继续可用、新版本资源自动下载”

### 6. 基准测试（可选）
`pnpm bench` 默认会对正例产物（dist/good）进行统计。

## 验证
完成以下验收即可通过本章节的测试：
- 反例输出固定文件名 `dist/bad/bundle.js`
- 正例输出带 hash 文件名 `dist/good/bundle.<hash>.js`
- 修改代码后二次构建，`dist/good` 至少保留两份不同 hash 的 bundle
完成以下验收：
- `pnpm run build` 产物文件名包含 hash
- 改动业务代码后重新构建，hash 变化
- 不改代码重复构建（尽量）hash 保持一致（视具体配置/插件而定）


