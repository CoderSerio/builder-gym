# 01 学习：为什么需要 contenthash？为什么要区分开发/生产？

## 本章节会解决什么问题
我们上线了一个网站，用户第一次访问会下载 `bundle.js`。
但是当我们发布新版本的页面时：
- 如果文件名仍叫 `bundle.js`，浏览器很可能会重新下载（缓存失效或被迫刷新）
- 你无法“只让变化的那部分重新下载”

因此需要：**缓存友好的文件命名策略**。

### 为什么“文件名不变”会导致缓存问题（用浏览器的视角理解）
浏览器缓存最重要的一点是：**缓存的 key 通常是 URL**（更准确说是：请求 URL + 一些请求头/响应头策略）。

这意味着：
- 第一次访问 `https://example.com/assets/bundle.js` → 浏览器下载并缓存一份“bundle.js 的内容”
- 第二次访问同一个 URL → 浏览器会尝试复用缓存（具体取决于 `Cache-Control` / `ETag` / `Last-Modified`）

问题出在“发布新版本”：
- 你更新了代码，但 URL 仍然是 `.../bundle.js`
- 浏览器并不知道这个 URL 背后的内容已经变了

为了保证用户拿到“新代码”，你通常会被迫：
- **不让它强缓存**（例如 `Cache-Control: no-cache`），导致每次都要去服务器校验甚至重新下载
- 或者在发布时做“缓存清理/刷新”，但这会影响体验且不可控

### 为什么说“无法只让变化的那部分重新下载”
如果你把所有东西都打进一个 `bundle.js`：
- 业务只改一行代码 → `bundle.js` 内容变了
- 因为 URL 不变，你只能让浏览器“重新获取 `bundle.js`”
- 结果是：即使大部分内容都没变，也会跟着一起重新下载（因为它们也在同一个文件里）

这就是我们说的：**你无法精确地只更新变化部分**。

### contenthash 的解法（核心直觉）
把文件名和“内容”绑定：
- 旧版本：`bundle.aaaa1111.js`
- 新版本：`bundle.bbbb2222.js`

好处是：
- **内容不变 → 文件名不变 → 浏览器可以长期强缓存**
- **内容变化 → 文件名变化 → 浏览器自动下载新文件**

你无需让 `bundle.js` 这种“稳定 URL”去承受版本变更压力。

### 为什么本关要“产出两份 bundle.<hash>.js”
为了把概念变成可观察的事实，本关正例构建会**故意保留旧产物**（不清理输出目录），让你看到：
- 第一次构建：`dist/good/bundle.aaaa1111.js`
- 改一行代码再构建：`dist/good/bundle.bbbb2222.js`

这代表现实中的关键能力：
- 老用户的 HTML 可能仍引用 `bundle.aaaa1111.js`（因为它已被缓存/已部署过）
- 新用户会拿到新的 HTML，从而引用 `bundle.bbbb2222.js`
- 两个版本可以在发布窗口期同时存在，便于平滑发布与回滚（真正的长效缓存）

## 本关需要安装哪些依赖（以及为什么）
```bash
pnpm add -D webpack webpack-cli swc-loader @swc/core style-loader css-loader
```
（与 00 类似，本关继续沿用）

## 为什么是 [contenthash]
webpack 的输出文件名支持模板占位符：
- `[contenthash]`：根据文件内容计算 hash（内容变 → hash 变）
- `[chunkhash]`：根据 chunk 计算
- `[hash]`：整个构建的 hash（不推荐，容易“全变”）

你要的效果是：**内容不变就复用缓存，内容变化才下载新文件**，因此 `[contenthash]` 最符合直觉。

## 为什么要区分 dev/prod
开发（dev）更关注：
- 快
- 好调试
- 文件名固定、简单

生产（prod）更关注：
- 体积小
- 可长期缓存
- 可控的 source map（通常关闭或单独上传）

因此常见做法是：
- dev：`bundle.js`
- prod：`bundle.[contenthash].js`

## 你最终要做到什么（验收标准）
- `pnpm run build` 产出带 hash 的文件名
- 修改源代码再构建，hash 改变
- 不改代码重复构建，hash 尽量保持稳定（后续关卡会深入“为什么有时不稳定”）


